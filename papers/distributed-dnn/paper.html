<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Clay McLeod, University of Mississippi, {clmcleod}@go.olemiss.edu">
  <title>A Framework for Distributed Deep Learning Layer Design in Python</title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="assets/fonts/cm/cm.css">
  <link rel="stylesheet" href="assets/css/academic-pub.css">
  <link rel="stylesheet" href="assets/css/ieee.css">
</head>
<body>
<header>
<h1 class="title">A Framework for Distributed Deep Learning Layer Design in Python</h1>
<h2 class="author">Clay McLeod, University of Mississippi, {clmcleod}@go.olemiss.edu</h2>
<h3 class="date">October 2015</h3>
</header>
<nav id="TOC">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#machine-learning-in-python">Machine Learning in Python</a><ul>
<li><a href="#benefits">Benefits</a><ul>
<li><a href="#simplicity">Simplicity</a></li>
<li><a href="#strong-open-source-community">Strong, Open Source Community</a></li>
<li><a href="#mature-scientific-libraries">Mature scientific libraries</a></li>
</ul></li>
<li><a href="#detriments">Detriments</a><ul>
<li><a href="#global-interpreter-lock">Global Interpreter Lock</a></li>
</ul></li>
</ul></li>
<li><a href="#objectives">Objectives</a></li>
<li><a href="#dependencies">Dependencies</a><ul>
<li><a href="#ecosystem">Ecosystem</a><ul>
<li><a href="#docker">Docker</a></li>
<li><a href="#coreos">CoreOS</a></li>
<li><a href="#rabbitmq">RabbitMQ</a></li>
<li><a href="#mongodb">MongoDB</a></li>
</ul></li>
<li><a href="#reporting-server">Reporting Server</a></li>
<li><a href="#python-libraries">Python Libraries</a><ul>
<li><a href="#flask">Flask</a></li>
<li><a href="#celery">Celery</a></li>
<li><a href="#numpy-scipy-pandas">NumPy, SciPy, Pandas</a></li>
<li><a href="#theano">Theano</a></li>
<li><a href="#pybrain">PyBrain</a></li>
<li><a href="#keras">Keras</a></li>
</ul></li>
</ul></li>
<li><a href="#system-design">System Design</a><ul>
<li><a href="#data-upload">Data Upload</a></li>
<li><a href="#tasks-management">Tasks Management</a></li>
<li><a href="#task-execution">Task Execution</a></li>
<li><a href="#results-storage-and-visualization">Results Storage and Visualization</a></li>
</ul></li>
<li><a href="#discussion">Discussion</a><ul>
<li><a href="#results">Results</a></li>
<li><a href="#improvementsfuture-work">Improvements/Future Work</a></li>
</ul></li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#references">References</a></li>
</ul>
</nav>
<div class="abstract">
Abstract - In this paper, a framework for testing Deep Neural Network (DNN) design in Python is presented. First, big data, machine learning (ML), and Artificial Neural Networks (ANNs) are discussed to familiarize the reader with the importance of such a system. Next, the benefits and detriments of implementing such a system in Python are presented. Lastly, the specifics of the system are explained, and some experimental results are presented to prove the effectiveness of the system.
</div>
<div id="main">
<h1 id="introduction">Introduction</h1>
<p>In recent years, the amount of data that is produced annually has increased dramatically <span class="citation" data-cites="big-data-1">[1]</span>, <span class="citation" data-cites="big-data-2">[2]</span>. The availability of this data has prompted researchers to publish large amounts of literature that study how we can make sense of this data, and, in turn, how can we handle this data in a computationally efficient manner <span class="citation" data-cites="big-data-3">[3]</span>, <span class="citation" data-cites="big-data-4">[4]</span>, <span class="citation" data-cites="hadoop">[5]</span>, <span class="citation" data-cites="spark">[6]</span>. The best performing methods involve a statistical technique called Machine Learning (ML), wherein we try to create a model of the data by taking advantage of a machine's high processing power <span class="citation" data-cites="ml-1">[7]</span>, <span class="citation" data-cites="ml-2">[8]</span>. For a complete overview of ML and the different algorithms involved, please refer to <span class="citation" data-cites="ml-book">[9]</span>. One particularly good ML algorithm for working with large amounts of data is a specific subset of Artificial Neural Networks (ANNs) <span class="citation" data-cites="nn-1">[10]</span>, <span class="citation" data-cites="nn-2">[11]</span>, called Deep Neural Networks (DNNs) <span class="citation" data-cites="dnn-1">[12]</span>, <span class="citation" data-cites="dnn-2">[13]</span>, <span class="citation" data-cites="dnn-book">[14]</span>. DNNs work well with large sets of data because of their peculiar quality of being a universal approximator <span class="citation" data-cites="universal-approximator-1">[15]</span>, <span class="citation" data-cites="universal-approximator-2">[16]</span>, which means that theoretically speaking, they can model any real function. This is extremely helpful in the case of big data because DNNs can flush out relationships within large amounts of data that humans would miss, due to our lower computational capacity. Lately, Python has become a language of choice for statisticians to model DNNs, partially because it abstracts away difficult language semantics, allowing researchers to focus mainly on the design of the algorithms rather than syntactical errors. Another key factor in Python's success in the DNN research space is due to it's portability and the large amount of scientific libraries that are actively being developed, such as Numpy <span class="citation" data-cites="numpy">[17]</span>, Scipy <span class="citation" data-cites="scipy">[18]</span>, Pandas <span class="citation" data-cites="pandas">[19]</span>, and Theano <span class="citation" data-cites="theano-1">[20]</span>, <span class="citation" data-cites="theano-2">[21]</span>. This ecosystem allows for high performance APIs with GPU acceleration to be run on a variety of different operating systems. In this paper, we will examine the benefits and detriments of using Python to model DNNs. Next, we will examine best practices for implementing a scalable infrastructure within which adding workers to the cluster is trivial. Lastly, some experimental results will be presented to show the effectiveness of this approach.</p>
<h1 id="machine-learning-in-python">Machine Learning in Python</h1>
<h2 id="benefits">Benefits</h2>
<h3 id="simplicity">Simplicity</h3>
<p>First, Python is a good language because it is an easily language to understand and program with. Because the barrier to begin programming in Python is so low, it attracts a large audience of people - especially experts from other academic backgrounds who have little programming experience but would like to take advantage of advanced computational processes.</p>
<h3 id="strong-open-source-community">Strong, Open Source Community</h3>
<p>Partially because of the simplicity referenced earlier, a strong community of academics has formed around the open source community. This allows libraries to evolve and improve at a rapid pace that is not reasonable when a small group of programmers is working on a closed source project. Thus, many Python libraries utilize cutting edge techniques and strong documentation pages. Many Python libraries also use nonrestrictive licenses, which also prompts businesses to use them and contribute back to the community.</p>
<h3 id="mature-scientific-libraries">Mature scientific libraries</h3>
<p>Furthermore, many experts in the scientific fields (wishing to reach the largest possible audience) focus exclusively on developing libraries in Python. This has lead to a mature, production tested ecosystem for developing applications in Python (see &quot;Dependencies&quot;).</p>
<h2 id="detriments">Detriments</h2>
<h3 id="global-interpreter-lock">Global Interpreter Lock</h3>
<p>One of the major roadblocks for implementing massively parallel systems in Python in the existence of the Global Interpreter Lock (GIL) <span class="citation" data-cites="gil-doc">[22]</span>. The GIL is necessary in the default Python implementation because Python's memory management system is not thread safe. Concretely, this means that means that no two Python threads can access a python object at the same time, which allows for concurrency, but not parallelism <span class="citation" data-cites="pydata-gil">[23]</span>. This restriction greatly reduces Python's ability to utilize multiple CPUs <span class="citation" data-cites="understanding-gil">[24]</span>. Furthermore, since the GIL has been implemented in Python since its inception, many other subsystems within Python's ecosystem have grown to rely on it's existence. Figure 1 shows the some core Python scientific libraries and their relationship with the GIL. Although several transpilers, such as IronPython and Jython, have overcome Python's reliance on the GIL, these transpilers have not been widely adopted due to their lack of full API support. No one has successfully implemented a solution for the GIL, so the problem still persists today.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<figure>
<img src="assets/img/jenga.png" title="Python scientific libraries and their reliance on the GIL [@pydata-gil]" alt="Python scientific libraries and their reliance on the GIL [23]" /><figcaption>Python scientific libraries and their reliance on the GIL <span class="citation" data-cites="pydata-gil">[23]</span></figcaption>
</figure>
<h1 id="objectives">Objectives</h1>
<p>Before system design is discussed, the objectives of this paper and the system should first be discussed. Many key goals were taken into consideration during the design of this system, namely:</p>
<ul>
<li><p><em>Best DNN layer design</em>: Although some literature exists on the practical design of deep neural networks <span class="citation" data-cites="design-dnn-1">[25]</span>, <span class="citation" data-cites="design-dnn-2">[26]</span>, <span class="citation" data-cites="design-dnn-3">[27]</span>, designing deep neural networks remains a mix of following these guidelines and mastering the &quot;black art&quot; of designing deep neural networks. This system was designed to discover what empirical design rules can be discovered about designing deep neural networks by systemically evaluating performance of (1000-50000) DNNs on the same dataset while varying the hyper-parameters and layer design.</p></li>
<li><p><em>Simplicity</em>: When designing large systems such as this, one might lose sight of the forest for the trees. In this implementation, simplicity is the stressed wherever possible. This allows the user to focus solely on the design of the DNN rather than fix system errors.</p></li>
<li><p><em>Fullstack Python</em>: For this implementation, a fullstack Python solution will be presented. This is not necessarily for performance benefits so much as it is for completeness: this objective is important because the reader is presumably familiar with Python, but not necessarily familiar with any other programming languages. Therefore, to appeal to as wide of an audience as possible, only Python will be used in this system. Optimization of different parts of this system are left as an exercise to the reader.</p></li>
<li><p><em>Dataset</em>: Briefly, we are focusing on a very particular type of dataset. Namely, datasets under 1TB that contain numerical features and are trying to predict a certain class for the label. Generally speaking, this system could potentially work for other variants of data (&gt; 1TB, regression problems). Due to the difficulty of addressing every type of problem that DNNs can solve exhaustively, those are left as an exercise to the reader. <em>Note</em>: For datasets larger than 1TB, this system will probably note work well for two reasons. First, uploading of a CSV bigger than 1TB is extremely cumbersome through a web api, usually causing modern web browsers to crash. Second, the system design proposed assumes that your dataset will fit trivially in memory. If your dataset is larger than 1TB, the reader is encouraged to use a different system, such as Hadoop <span class="citation" data-cites="hadoop">[5]</span>.</p></li>
<li><p><em>Easy deployment</em>: Another key goal of this system design was to ensure ease/quickness of deployment across the system when testing rules and other code changes were applied to the code base. Since most researchers studying DNN design are not expert system administrators, this step is crucial to ensuring efficient research on DNNs.</p></li>
<li><p><em>GPU acceleration</em>: Although not true for every machine, some machines are equipped with graphic processing units (GPUs), which can be utilized to greatly decrease running time for training DNNs <span class="citation" data-cites="gpu">[28]</span>. Therefore, this system ensures that each machine that has a GPU available will take advantage of this asset.</p></li>
</ul>
<h1 id="dependencies">Dependencies</h1>
<p>In the following sections, the <strong>host machine</strong> refers to a single machine that coordinates the cluster of worker machines. This includes distributed jobs through the message queue (see &quot;RabbitMQ&quot;), the database (see &quot;MongoDB&quot;), and the HTTP reporting server (see &quot;Reporting Server&quot;). A <strong>worker machine</strong> is a dispensable machine that runs tasks as it receives it from the host machine. This system has only been tested on Python 2.7, but porting to Python 3.X should be trivial.</p>
<h2 id="ecosystem">Ecosystem</h2>
<h3 id="docker">Docker</h3>
<p>Docker is a lightweight Linux container system that allows you to compile a specific Linux image once and deploy that image to multiple destinations with ease <span class="citation" data-cites="docker">[29]</span>. Concretely, we can compile a Ubuntu Linux image with the correct Python libraries installed then deploy our image to each of our worker servers with ease. Docker runs on top of most (if not all) major operating systems and takes up little overhead. For more information on configuring Docker or its capabilities, visit <span class="citation" data-cites="docker-docs">[30]</span>.</p>
<h3 id="coreos">CoreOS</h3>
<p>CoreOS is a lightweight, flexible operating system that runs containers on top of it <span class="citation" data-cites="coreos">[31]</span>. CoreOS has auto-clustering and job deployment (called services) baked in. In addition, the CoreOS team has built a painless distributed key-value store called <strong>etcd</strong> <span class="citation" data-cites="etcd">[32]</span> that comes with the operating system. Although many of these features are not applicable to this particular paper, utilization of these features could further improve upon the proposed implementation.</p>
<h3 id="rabbitmq">RabbitMQ</h3>
<p>RabbitMQ is a robust message queue implementation that is easy, portable, and supports a number of messaging protocols, including the popular AMPQ protocol <span class="citation" data-cites="rabbitmq">[33]</span>. Message queues <span class="citation" data-cites="message-queue">[34]</span> are crucial when building a distributed computing platform utilizing Python, because it provides a centralized pool of tasks for each of your worker machines to pull from. The decision to use this particular messaging queue to store future parameters is based on the reputation of RabbitMQ being a battle-tested, production ready product. However, other similar task storing systems, such as Redis <span class="citation" data-cites="redis">[35]</span>, are worth mentioning.</p>
<h3 id="mongodb">MongoDB</h3>
<p>MongoDB is a NoSQL database that offers easy storage and installation <span class="citation" data-cites="mongodb">[36]</span>. This is one of the few components of the proposed system that is chosen purely by preference instead of some performance based metric. As previously stated, one of the major goals of this project is to keep the solution as simple as possible. MongoDB helps achieve this goal because of the vast amount of documentation available, the ease of installation/management, and the availability of well-documented libraries to interact with it. However, since MongoDB is only used for results storage, any database you like could be used here. A comprehensive comparison of databases and their trade offs can be found in <span class="citation" data-cites="db-tradeoffs">[37]</span>.</p>
<h2 id="reporting-server">Reporting Server</h2>
<p>The reporting server was built on a web platform, utilizing HTML5, CSS3, and JavaScript. Notable libraries and their functions include:</p>
<ul>
<li>NGINX (<a href="http://www.nginx.com/" class="uri">http://www.nginx.com/</a>): Serve static web pages and reverse proxy reporting server.</li>
<li>Bootstrap (<a href="http://getbootstrap.com/" class="uri">http://getbootstrap.com/</a>): CSS Styling library provided by Twitter.</li>
<li>jQuery (<a href="http://jquery.com" class="uri">http://jquery.com</a>): DOM manipulation and communication with backend REST server.</li>
<li>plot.ly (<a href="http://plot.ly" class="uri">http://plot.ly</a>): Plotting results, manipulating graphs, and exporting results.</li>
<li>Papa Parse (<a href="http://papaparse.com/" class="uri">http://papaparse.com/</a>): JS library for easily parsing CSV files.</li>
</ul>
<h2 id="python-libraries">Python Libraries</h2>
<h3 id="flask">Flask</h3>
<p>Flask is a microframework for building web services uses Python <span class="citation" data-cites="flask">[38]</span>. In this system, Flask acts as the middleman between the website and the database by exposing a REST api <span class="citation" data-cites="rest-api">[39]</span> (see &quot;System Design&quot;). Although not suitable for larger project because of its long-blocking operations, Flask was used in this system because of its simplicity and the commitment to write as much of the system as possible using fullstack Python.</p>
<h3 id="celery">Celery</h3>
<p>Celery is an &quot;asynchronous task queue/job queue based on distributed message passing&quot; <span class="citation" data-cites="celery">[40]</span>. Celery is crucial for the system presented as it abstracts away all the intricacies of building a distributed worker system, exposing an easy to use API for writing distributed Python applications. Furthermore, there are several niceties built in, such as compatibility with many major message queues/databases (namely RabbitMQ, Redis, MongoDB) and web interfaces for monitoring performance.</p>
<h3 id="numpy-scipy-pandas">NumPy, SciPy, Pandas</h3>
<p>NumPy <span class="citation" data-cites="numpy">[17]</span>, SciPy <span class="citation" data-cites="scipy">[18]</span>, and Pandas <span class="citation" data-cites="pandas">[19]</span> are the foundational scientific libraries upon which most other major Python libraries are built. These libraries provide low level optimizations for scientific computation across platforms. Furthermore, adoption of a common set of libraries allows for easy interaction between different libraries. Concretely, NumPy provides basic array functionality, SciPy provides a suit of scientific functions and calculations (such as optimization and statistical operations), and Pandas provides a common interface for formatting and manipulating data. Of course, each of these does much more than these functions, and the reader is encouraged to read their respective documentations to gain a comprehensive list of the benefits for using each.</p>
<h3 id="theano">Theano</h3>
<p>Theano is a symbolic Python library that allows you to &quot;define, optimize, and evaluate mathematical expressions with multi-dimensional arrays efficiently&quot; <span class="citation" data-cites="theano-1">[20]</span>, <span class="citation" data-cites="theano-2">[21]</span>. Developed at the Université de Montréal by leading DNN researchers, Theano plays a crucial role in the DNN development stack. Theano allows easy GPU integration, provides several key deep neural network functions (such as activation functions), and, because of its symbolic natural, greatly simplifies the math for the user by automatically computing complicated gradient functions, as well as other complex mathematic equations.</p>
<h3 id="pybrain">PyBrain</h3>
<p>PyBrain aims to offer a high performance neural network library without the complicated entry barrier that most users experience when trying to enter the field <span class="citation" data-cites="pybrain">[41]</span>. Developed independently at Technische Universität München, PyBrain does <strong>not</strong> rely on Theano, and therefore, does not take advantage of the GPU acceleration or optimized mathematical functions Theano provides. However, it has been selected as one of the DNN libraries because of its flexibility and ease of use.</p>
<h3 id="keras">Keras</h3>
<p>Keras lives at the other end of the neural network library spectrum <span class="citation" data-cites="keras">[42]</span>. Keras <strong>is</strong> built on top of Theano, and is closely integrated with Theano under the hood. It takes full advantage of Theano's optimizations wherever possible, and encourages its users to use best practices and the latest DNN techniques. The barrier to learn Keras and realize its full potential is slightly higher than that of PyBrain. However, given its expressive and powerful nature, the tradeoff is well worth it.</p>
<h1 id="system-design">System Design</h1>
<p>For the purposes of this discussion, there are four atomic units of functionality, all working asynchronously with each other. These units of functionality include uploading the data (see &quot;Data Upload), initializing tasks to run for that data (see &quot;Task Management&quot;), executing the tasks (see &quot;Task Execution&quot;), and storing/visualizing the results (see &quot;Results Storage and Visualization&quot;). Because these units operate independently of each other, failure in the pipeline can occur in one stage of the pipeline without affecting the performance of another stage. Each stage &quot;fails forward&quot;, meaning that if a failure occurs, the system merely presents the appropriate error and keeps executing its next task rather than crashing. These are all principles the reader is encouraged to follow when creating their own systems.</p>
<h2 id="data-upload">Data Upload</h2>
<p>First, a static website was created for uploading data to the server to be processed. This server used a standard Bootstrap template and exposed an interface to upload a CSV file, since most datasets are easily represented as this type of file. Next, the Papa Parse library was used to parse the CSV file to a multidimensional JavaScript array. If Papa Parse encountered an error in parsing the file (such as incorrect format), it would through an error, which would be communicated to the user and the process would be aborted. <em>Note</em>: missing data was not considered an error, due to the desired compatibility with sparse datasets. If the dataset <em>was</em> properly formatted, the user was prompted to choose a &quot;label&quot; (what value of the data we would like to predict), and Papa Parse would then hand off the data the jQuery, which would attempt to upload the data to the Flask REST api. Upon success, jQuery received a &quot;Session ID&quot; from the server, which was a unique identifier that could be used to check on the progress/results of any given session. At this point, the function of the web interface is mostly done - if the user chooses to stay on the page, jQuery continuously checks back with the server on the progress of that session and updates a progress bar accordingly. When the current session completes, the user is presented a link to review the results visualization. Figure 2 shows the flowchart for the web interface.</p>
<figure>
<img src="assets/img/web-interface-flowchart.png" title="Web interface process" alt="Flowchart showing web interface process" /><figcaption>Flowchart showing web interface process</figcaption>
</figure>
<p>Although we have discussed the function of the static website, deployment of this website has not yet been discussed. This is where Docker plays a crucial role in flexible deployment. First, a Docker image was compiled from the base NGINX image. Concretely, Docker has several precompiled containers available at <span class="citation" data-cites="docker-hub">[43]</span> that you can base your image off of. In this particular image, NGINX is already preconfigured and running on top of the Ubuntu operating system. Simply copy your static website files into the location specified on the NGINX container page and you have a fully portable image ready to serve your static website.</p>
<p>In this system, the Docker image serving our website is run on top of the host machine for low latency communications with the database and REST api. Port 80 of the host machine is mapped to the port that NGINX is serving the website on inside of the container, meaning anyone who visited the host machine's public IP address would get served the website.</p>
<h2 id="tasks-management">Tasks Management</h2>
<p>It has been hinted that the relationship between RabbitMQ and Celery is an integral part of this system. As discussed earlier, setting up a RabbitMQ server is very easy using Docker - simply run the default RabbitMQ container provided at <span class="citation" data-cites="docker-hub">[43]</span> with the web interface enabled. In this system, the RabbitMQ container was run on the host machine for low latency communication with the Flask server. For the Celery instance, a separate Docker container was created on top of the default Python 2.7 container <span class="citation" data-cites="docker-hub">[43]</span> that handles the running of the Flask/Celery Python microframework. Because all of these Docker containers are run on the same machine and the ports are mapped to the host machine, communication between Docker containers is seamless.</p>
<p>Once this JavaScript array has been passed off to the Flask server, the user can preprocess the data as the like to prepare it for training. This unit of functionality (as well as &quot;Task Execution&quot;) is where most of the &quot;black magic&quot; of designing DNNs comes into play. In this system, a few simple experiments were designed to test different hyper-parameters and layer designs across different datasets. Although the specific of that design will be discussed here, the reader is encouraged to come up with their own rules for designing their DNNs.</p>
<p>First, missing values were filled with zeroes (necessary for processing in neural networks). Next, some best practices for working with DNNs were implemented:</p>
<ol type="1">
<li><p>All of the features (every value in the dataset except for the label) were scaled from [0..1] <span class="citation" data-cites="design-dnn-1">[25]</span>.</p></li>
<li><p>Label data was split into categories and encoded using a technique called &quot;One Hot Encoding&quot;. This creates a different output node in the DNN for each categorical answer and allows the DNN to output a probability that any given categorical answer is the correct one <span class="citation" data-cites="design-dnn-1">[25]</span>.</p></li>
<li><p>The data was split into two distinct sets: 80% training and 20% testing. Holding out some data for testing a DNN helps to alleviate overfitting <span class="citation" data-cites="nn-overfitting">[44]</span>.</p></li>
</ol>
<p>After the data has been preprocessed, it can be passed off to different subsystems in the &quot;Task Execution&quot; unit for processing by Keras and PyBrain. This is easily accomplished by creating two distinct celery tasks for training a DNN with PyBrain and Keras respectively. Depending on which library you would like to train with, you can submit jobs with varying hyper-parameters and layers for processing in this stage of the pipeline. Celery will serialize of this data into RabbitMQ and execute these training tasks as worker machines become available. Figure 3 shows the flowchart for the Task Management pipeline.</p>
<figure>
<img src="assets/img/task-management-flowchart.png" title="Task management process" alt="Flowchart showing task management process" /><figcaption>Flowchart showing task management process</figcaption>
</figure>
<h2 id="task-execution">Task Execution</h2>
<p>As discussed in &quot;Task Management&quot;, this unit of operation simply implements a training function for either Keras/PyBrain that trains the DNN based on the parameters provided by Celery. This is a simple as writing a single method and letting Celery run these training methods as the workers become available. What is not trivial, however, is the rapid deployment on new workers into the system.</p>
<p>A Docker container was built on top of the default Python 2.7 image <span class="citation" data-cites="docker-hub">[43]</span> that ran an instance of a Celery worker. In this way, anytime you deploy this Docker container to a worker machine, another worker was made available in the Celery worker cluster. The key to optimizing efficiency is to take advantage of:</p>
<ol type="1">
<li>Worker machines with GPU acceleration.</li>
<li>Worker machines with multiple cores.</li>
</ol>
<p>To take advantage of multiple CPU cores, simply set the &quot;THEANO_FLAGS&quot; environment variable in the Docker as follows:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ot">THEANO_FLAGS=</span>device=<span class="kw">gpu</span>,floatX=float32</code></pre></div>
<p>You can specific this when you are deploying on a machine you know has a GPU, or you can just always set the environment variable, as Theano recognizing when the machine you are running is not configured with a GPU.</p>
<p>One of the nice features about using a task scheduler like Celery is that is has built in multi-process support. Meaning that you can simply pass in a command line argument indicating the number of worker processes you would like when starting a Celery worker is started, and Celery will handle the logistics for you. For most use cases, a number of workers equal to the number of cores on your worker machine is recommended for optimal performance. Another alternative is to spawn multiple Docker containers with a lower amount of workers, although this approach is not quite as memory efficient due to the overhead of running multiple Ubuntu instances. Figure 4 shows the flowchart for the Task Execution process.</p>
<figure>
<img src="assets/img/task-execution-flowchart.png" title="Task execution process" alt="Flowchart showing task execution process" /><figcaption>Flowchart showing task execution process</figcaption>
</figure>
<h2 id="results-storage-and-visualization">Results Storage and Visualization</h2>
<p>After processing by the Task Execution subsystem, results are stored in the MongoDB instance. A default MongoDB container <span class="citation" data-cites="docker-hub">[43]</span> was instantiated on the host machine, allowing for low latency communication with the Flask server and a centralized datastore. A RESTful API was used to access the MongoDB results from the client. Some information stored in the database includes the session id, the training time, the model accuracy, and the parameters used to train the model. Other niceties of this setup include a web interface for monitoring both Celery and RabbitMQ. Figures 5-7 show these reporting features.</p>
<figure>
<img src="assets/img/plotly.png" title="Training Time vs. Hidden Layers" alt="Example of plot.ly showing training time vs. hidden layers" /><figcaption>Example of plot.ly showing training time vs. hidden layers</figcaption>
</figure>
<figure>
<img src="assets/img/rabbitmq-dash.png" title="RabbitMQ dashboard" alt="RabbitMQ dashboard when uploading 20,000 jobs" /><figcaption>RabbitMQ dashboard when uploading 20,000 jobs</figcaption>
</figure>
<figure>
<img src="assets/img/celery-dash.png" title="Celery dashboard" alt="Celery dashboard showing worker status" /><figcaption>Celery dashboard showing worker status</figcaption>
</figure>
<h1 id="discussion">Discussion</h1>
<h2 id="results">Results</h2>
<p>Discussion of results is not the main focus of this paper, and research on what a systematic approach to studying DNNs is still ongoing. However, a few preliminary observations stand out for those interested:</p>
<ul>
<li><p>Every DNN tested, on small datasets and large datasets, seem to reach a &quot;critical mass&quot; of information storage around 500-700 hidden layers, wherein the DNNs performance will flatline for any number of layers greater than the critical mass point. Quite probably, this is due to overfitting of the deep neural network to the training data and is not a significant finding, except to encourage designers to use as few layers as possible to avoid overfitting. <em>Note</em>: this premise was not exhaustively tested against all kinds of layers and activation functions, but a significant number of combinations were tried.</p></li>
<li><p>Training of DNN increases roughly linearly with the amount of layers added to the network for a significant number of layer combinations tried (see Figure 5).</p></li>
<li><p>Granular control over parameters greatly increases performance in DNNs. For instance, testing several different combinations of activation functions will produce some interesting results.</p></li>
</ul>
<h2 id="improvementsfuture-work">Improvements/Future Work</h2>
<p>Several improvements are possible, notably:</p>
<ul>
<li><p><em>Asynchronous REST API</em>: This focus of this experiment was to build a full stack Python system to train DNNs. However, this is generally not optimal for asynchronous applications such as a REST API. The reader is encouraged to look for alternatives outside of the Python programming language, such as NodeJS <span class="citation" data-cites="nodejs">[45]</span> or golang <span class="citation" data-cites="golang">[46]</span>, to build their RESTful API, as Python's blocking nature presents major speed issues.</p></li>
<li><p><em>Granular web interface</em>: Rather than programming the rules for choosing training parameters directly, it is conceivable that you could build this functionality into the web user interface, allowing DNN designers not familiar with a specific library to set these training rules through a GUI.</p></li>
</ul>
<h1 id="conclusion">Conclusion</h1>
<p>To conclude, a distributed, fullstack Python implementation was described in detail for examining performance results for different parameters in DNN training. This is potentially useful because the design of DNNs is more of an art than a science, so the more we can find out about how different hyper-parameters/layers affect the accuracy of a deep neural network, the better. By utilizing several deployment tools (Docker <span class="citation" data-cites="docker">[29]</span>, CoreOS <span class="citation" data-cites="coreos">[31]</span>), production grade distributed solutions (RabbitMQ <span class="citation" data-cites="rabbitmq">[33]</span>, MongoDB <span class="citation" data-cites="mongodb">[36]</span>), and the Python scientific ecosystem (NumPy <span class="citation" data-cites="numpy">[17]</span>, SciPy <span class="citation" data-cites="scipy">[18]</span>, Theano <span class="citation" data-cites="theano-1">[20]</span>, <span class="citation" data-cites="theano-2">[21]</span>, Keras <span class="citation" data-cites="keras">[42]</span>, PyBrain <span class="citation" data-cites="pybrain">[41]</span>), such a system is easily implemented in a flexible way that prioritizes simplicity and modularity. Some preliminary discoveries are discussed, and work to build off of the current implementation is also presented.</p>
<h1 id="references" class="references unnumbered">References</h1>
<div id="ref-big-data-1">
<p>[1] J. Manyika, M. Chui, B. Brown, J. Bughin, R. Dobbs, C. Roxburgh, and A. H. Byers, “Big data: The next frontier for innovation, competition, and productivity,” 2011.</p>
</div>
<div id="ref-big-data-2">
<p>[2] V. Mayer-Schönberger and K. Cukier, <em>Big data: A revolution that will transform how we live, work, and think</em>. Houghton Mifflin Harcourt, 2013.</p>
</div>
<div id="ref-big-data-3">
<p>[3] P. Russom and others, “Big data analytics,” <em>TDWI Best Practices Report, Fourth Quarter</em>, 2011.</p>
</div>
<div id="ref-big-data-4">
<p>[4] P. Zikopoulos, C. Eaton, and others, <em>Understanding big data: Analytics for enterprise class hadoop and streaming data</em>. McGraw-Hill Osborne Media, 2011.</p>
</div>
<div id="ref-hadoop">
<p>[5] K. Shvachko, H. Kuang, S. Radia, and R. Chansler, “The hadoop distributed file system,” in <em>Mass storage systems and technologies (mSST), 2010 iEEE 26th symposium on</em>, 2010, pp. 1–10.</p>
</div>
<div id="ref-spark">
<p>[6] M. Zaharia, M. Chowdhury, M. J. Franklin, S. Shenker, and I. Stoica, “Spark: Cluster computing with working sets,” in <em>Proceedings of the 2nd uSENIX conference on hot topics in cloud computing</em>, 2010, vol. 10, p. 10.</p>
</div>
<div id="ref-ml-1">
<p>[7] D. E. Goldberg and J. H. Holland, “Genetic algorithms and machine learning,” <em>Machine learning</em>, vol. 3, no. 2, pp. 95–99, 1988.</p>
</div>
<div id="ref-ml-2">
<p>[8] J. G. Carbonell, R. S. Michalski, and T. M. Mitchell, “An overview of machine learning,” in <em>Machine learning</em>, Springer, 1983, pp. 3–23.</p>
</div>
<div id="ref-ml-book">
<p>[9] R. S. Michalski, J. G. Carbonell, and T. M. Mitchell, <em>Machine learning: An artificial intelligence approach</em>. Springer Science &amp; Business Media, 2013.</p>
</div>
<div id="ref-nn-1">
<p>[10] S. Haykin and N. Network, “A comprehensive foundation,” <em>Neural Networks</em>, vol. 2, no. 2004, 2004.</p>
</div>
<div id="ref-nn-2">
<p>[11] M. T. Hagan, H. B. Demuth, M. H. Beale, and others, <em>Neural network design</em>. Pws Pub. Boston, 1996.</p>
</div>
<div id="ref-dnn-1">
<p>[12] J. Schmidhuber, “Deep learning in neural networks: An overview,” <em>CoRR</em>, vol. abs/1404.7828, 2014.</p>
</div>
<div id="ref-dnn-2">
<p>[13] Y. Bengio, A. C. Courville, and P. Vincent, “Unsupervised feature learning and deep learning: A review and new perspectives,” <em>CoRR</em>, vol. abs/1206.5538, 2012.</p>
</div>
<div id="ref-dnn-book">
<p>[14] Y. Bengio, I. J. Goodfellow, and A. Courville, “Deep learning,” 2015.</p>
</div>
<div id="ref-universal-approximator-1">
<p>[15] K. Hornik, M. Stinchcombe, and H. White, “Multilayer feedforward networks are universal approximators,” <em>Neural networks</em>, vol. 2, no. 5, pp. 359–366, 1989.</p>
</div>
<div id="ref-universal-approximator-2">
<p>[16] M. Leshno, V. Y. Lin, A. Pinkus, and S. Schocken, “Multilayer feedforward networks with a nonpolynomial activation function can approximate any function,” <em>Neural networks</em>, vol. 6, no. 6, pp. 861–867, 1993.</p>
</div>
<div id="ref-numpy">
<p>[17] N. team, “NumPy GitHub repository,” <em>GitHub repository</em>. GitHub, 2015.</p>
</div>
<div id="ref-scipy">
<p>[18] E. Jones, T. Oliphant, P. Peterson, and others, “SciPy: Open source scientific tools for Python.” 2001–2001--.</p>
</div>
<div id="ref-pandas">
<p>[19] W. McKinney, “Data structures for statistical computing in python,” in <em>Proceedings of the 9th python in science conference</em>, 2010, pp. 51–56.</p>
</div>
<div id="ref-theano-1">
<p>[20] F. Bastien, P. Lamblin, R. Pascanu, J. Bergstra, I. J. Goodfellow, A. Bergeron, N. Bouchard, and Y. Bengio, “Theano: New features and speed improvements.” Deep Learning and Unsupervised Feature Learning NIPS 2012 Workshop, 2012.</p>
</div>
<div id="ref-theano-2">
<p>[21] J. Bergstra, O. Breuleux, F. Bastien, P. Lamblin, R. Pascanu, G. Desjardins, J. Turian, D. Warde-Farley, and Y. Bengio, “Theano: A CPU and GPU math expression compiler,” in <em>Proceedings of the python for scientific computing conference (SciPy)</em>, 2010.</p>
</div>
<div id="ref-gil-doc">
<p>[22] P. Foundation, “Global interpreter lock documentation,” 2015. [Online]. Available: <a href="https://wiki.python.org/moin/GlobalInterpreterLock" class="uri">https://wiki.python.org/moin/GlobalInterpreterLock</a>. [Accessed: 23-Oct-2015].</p>
</div>
<div id="ref-pydata-gil">
<p>[23] M. Rocklin, “PyData and the gIL,” 2015.</p>
</div>
<div id="ref-understanding-gil">
<p>[24] D. Beazley, “Understanding the python gIL.” 20-Feb-2010.</p>
</div>
<div id="ref-design-dnn-1">
<p>[25] G. Hinton, “A practical guide to training restricted boltzmann machines,” <em>Momentum</em>, vol. 9, no. 1, p. 926, 2010.</p>
</div>
<div id="ref-design-dnn-2">
<p>[26] Y. Bengio, “Practical recommendations for gradient-based training of deep architectures,” in <em>Neural networks: Tricks of the trade</em>, Springer, 2012, pp. 437–478.</p>
</div>
<div id="ref-design-dnn-3">
<p>[27] G. E. Hinton, N. Srivastava, A. Krizhevsky, I. Sutskever, and R. R. Salakhutdinov, “Improving neural networks by preventing co-adaptation of feature detectors,” <em>arXiv preprint arXiv:1207.0580</em>, 2012.</p>
</div>
<div id="ref-gpu">
<p>[28] J. D. Owens, M. Houston, D. Luebke, S. Green, J. E. Stone, and J. C. Phillips, “GPU computing,” <em>Proceedings of the IEEE</em>, vol. 96, no. 5, pp. 879–899, 2008.</p>
</div>
<div id="ref-docker">
<p>[29] D. Merkel, “Docker: Lightweight linux containers for consistent development and deployment,” <em>Linux J.</em>, vol. 2014, no. 239, Mar. 2014.</p>
</div>
<div id="ref-docker-docs">
<p>[30] D. Team, “Docker documentation,” 2015. [Online]. Available: <a href="http://docs.docker.com" class="uri">http://docs.docker.com</a>. [Accessed: 24-Oct-2015].</p>
</div>
<div id="ref-coreos">
<p>[31] C. Team, “CoreOS website,” 2015. [Online]. Available: <a href="https://coreos.com/" class="uri">https://coreos.com/</a>. [Accessed: 24-Oct-2015].</p>
</div>
<div id="ref-etcd">
<p>[32] C. team, “CoreOS GitHub repository,” <em>GitHub repository</em>. <a href="https://github.com/coreos/etcd" class="uri">https://github.com/coreos/etcd</a>; GitHub, 2015.</p>
</div>
<div id="ref-rabbitmq">
<p>[33] R. Team, “RabbitMQ website,” 2015. [Online]. Available: <a href="https://www.rabbitmq.com/" class="uri">https://www.rabbitmq.com/</a>. [Accessed: 24-Oct-2015].</p>
</div>
<div id="ref-message-queue">
<p>[34] E. A. Brewer, F. T. Chong, L. T. Liu, S. D. Sharma, and J. D. Kubiatowicz, “Remote queues: Exposing message queues for optimization and atomicity,” in <em>Proceedings of the seventh annual aCM symposium on parallel algorithms and architectures</em>, 1995, pp. 42–53.</p>
</div>
<div id="ref-redis">
<p>[35] R. Team, “Redis website,” 2015. [Online]. Available: <a href="https://www.redis.io/" class="uri">https://www.redis.io/</a>. [Accessed: 24-Oct-2015].</p>
</div>
<div id="ref-mongodb">
<p>[36] M. Team, “MongoDB website,” 2015. [Online]. Available: <a href="https://www.mongodb.com/" class="uri">https://www.mongodb.com/</a>. [Accessed: 24-Oct-2015].</p>
</div>
<div id="ref-db-tradeoffs">
<p>[37] K. Kovacs, “Cassandra vs mongoDB vs couchDB vs redis vs riak vs hBase vs couchbase vs orientDB vs aerospike vs neo4j vs hypertable vs elasticSearch vs accumulo vs voltDB vs scalaris vs rethinkDB comparison,” 2015. [Online]. Available: <a href="http://kkovacs.eu/cassandra-vs-mongodb-vs-couchdb-vs-redis" class="uri">http://kkovacs.eu/cassandra-vs-mongodb-vs-couchdb-vs-redis</a>. [Accessed: 24-Oct-2015].</p>
</div>
<div id="ref-flask">
<p>[38] F. team, “Flask website.” 2015.</p>
</div>
<div id="ref-rest-api">
<p>[39] M. Masse, <em>REST aPI design rulebook</em>. “ O’Reilly Media, Inc.”, 2011.</p>
</div>
<div id="ref-celery">
<p>[40] C. team, “Celery website.” 2015.</p>
</div>
<div id="ref-pybrain">
<p>[41] T. Schaul, J. Bayer, D. Wierstra, Y. Sun, M. Felder, F. Sehnke, T. Rückstieß, and J. Schmidhuber, “PyBrain,” <em>Journal of Machine Learning Research</em>, vol. 11, pp. 743–746, 2010.</p>
</div>
<div id="ref-keras">
<p>[42] F. et a. Chollet, “Keras website,” 2015. [Online]. Available: <a href="http://keras.io" class="uri">http://keras.io</a>. [Accessed: 24-Oct-2015].</p>
</div>
<div id="ref-docker-hub">
<p>[43] D. Team, “Docker hub,” 2015. [Online]. Available: <a href="http://hub.docker.com" class="uri">http://hub.docker.com</a>. [Accessed: 25-Oct-2015].</p>
</div>
<div id="ref-nn-overfitting">
<p>[44] I. V. Tetko, D. J. Livingstone, and A. I. Luik, “Neural network studies. 1. comparison of overfitting and overtraining,” <em>Journal of chemical information and computer sciences</em>, vol. 35, no. 5, pp. 826–833, 1995.</p>
</div>
<div id="ref-nodejs">
<p>[45] N. team, “NodeJS website,” 2015. [Online]. Available: <a href="http://nodejs.org/" class="uri">http://nodejs.org/</a>. [Accessed: 25-Oct-2015].</p>
</div>
<div id="ref-golang">
<p>[46] Google, “Golang website,” 2015. [Online]. Available: <a href="http://golang.org/" class="uri">http://golang.org/</a>. [Accessed: 25-Oct-2015].</p>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Note that a Python interpreter is just a C level program. Whenever this C level program accesses a Python object, the GIL is locked for that process. However, different processes on a UNIX system have exclusive memory spaces, so each subprocess of Python has it's own GIL. This alleviates some of the problems introduced by the GIL, but objects still have serialized and deserialized for objects to communicate, which can be costly. Credit: email correspondence with Matthew Rocklin<a href="#fnref1">↩</a></p></li>
</ol>
</section>
</div>
</body>
</html>
